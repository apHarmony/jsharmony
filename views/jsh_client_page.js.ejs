/*
Copyright 2017 apHarmony

This file is part of jsHarmony.

jsHarmony is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

jsHarmony is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this package.  If not, see <http://www.gnu.org/licenses/>.
*/

(function(){

  var XExt = jsh.XExt;
  var XPage = jsh.XPage;

  XPage.handlePopState = function(event){
    var state = event.state;

    var loadPrevious = function () {
      if (!XPage.LoadState(state, {addBackHistoryOnCancel: true, _GET: XExt.parseGET()})) return;
      XPage.Select({ force: true });
    };

    if (_.isObject(state)) {
      var drslt = XPage.OnExit();
      if (drslt) {
        XExt.Confirm(drslt + '\r\n\r\nAre you sure you want to leave this page?', function(){
          jsh.cancelExit = true;
          loadPrevious();
        }, function () {
          XPage.AddHistory(jsh.state, true);
        });
        return;
      }
    }
    loadPrevious();
  }

  XPage.OnExit = function() {
    if (!jsh.init_complete) return;

    var msg = XPage.GetChangesMessage();
    if (msg) return msg;
  }

  //Checks if the page has changes, and if so, display a confirmation if they should be ignored.
  XPage.CheckChanges = function(rootid, onContinue, onCancel) {
    if(!onContinue) onContinue = function(){};
    var msg = XPage.GetChangesMessage(rootid);
    if(msg){
      XExt.Confirm(msg + '  Are you sure you want to continue?', onContinue, onCancel);
    }
    else onContinue();
  }

  //Checks if the target model or any of its descendents are editable
  XPage.HasEditableModel = function(rootid) {
    var rslt = false;
    rootid = XExt.resolveModelID(rootid);
    if(!rootid) rootid = jsh.XModels_root;
    XPage.traverseModels(rootid, function (xmodel) {
      if (!xmodel.isEnabled()){ return; }
      if (!XExt.hasAction(xmodel.actions, 'IUD')) return;
      rslt = true;
    });
    return rslt;
  }

  //Generates a string message of unsaved changes
  XPage.GetChangesMessage = function(rootid){
    var foundchanges = XPage.GetChanges(rootid);

    if (foundchanges.length > 0) {
      var msg = 'You have unsaved changes to ';
      for (var i = 0; i < foundchanges.length; i++) {
        msg += foundchanges[i];
        if (i < foundchanges.length - 2) msg += ', ';
        else if (i == foundchanges.length - 2) msg += ' and ';
      }
      msg += ' data.';
      return msg;
    }
  }

  //Check for unsaved changes, and returns array of form names that have changed
  XPage.GetChanges = function(rootid) {
    var foundchanges = [];
    rootid = XExt.resolveModelID(rootid);
    if(!rootid) rootid = jsh.XModels_root;
    XPage.traverseModels(rootid, function (xmodel) {
      if (!xmodel.isEnabled()){ return; }
      if (!XExt.hasAction(xmodel.actions, 'IUD')) return;
      if (xmodel.controller.HasUpdates()) { foundchanges.push(xmodel.caption[1]); }
      else if (xmodel.controller.form && xmodel.controller.form.Data && xmodel.controller.form.Data._is_dirty) { foundchanges.push(xmodel.caption[1]); }
    });
    return foundchanges;
  }

  XPage.Save = function(options) {
    if(!jsh.XModels_root){ XExt.Alert('No root model configured'); return; }
    if (!options) options = {};
    if (!options.onFail) options.onFail = function () { };
    var dbtasks = [];
    var valid = true;
    //For each model: Commit, validate, and get save operation tasks
    XPage.traverseModels(null, function (xmodel) {
      if (!valid) return;
      if (XExt.hasAction(xmodel.actions, 'IUD') && !xmodel.unbound) {
        var action = 'U';
        if (xmodel.layout == 'multisel') action = 'U';
        else if (xmodel.layout == 'grid') action = 'IUD';
        else if (xmodel.controller.form.Data._is_insert) action = 'I';
        if (XExt.hasAction(xmodel.actions, action)) {
          var ftasks = xmodel.controller.Save();
          if (typeof ftasks == 'undefined') { valid = false; return; }
          dbtasks = _.union(dbtasks, ftasks);
        }
      }
      else if(XExt.hasAction(xmodel.actions, 'B')) {
        if (xmodel.layout == 'multisel') {}
        else if(xmodel.controller.form && !xmodel.controller.form.Data.Commit()){ valid = false; return; }
      }
    });
    if (!valid) return options.onFail('validation');
    //Run custom form validation /  async validation
    XPage.traverseModelsAsync(jsh.XModels_root, function (xmodel, done) {
      if (!valid) return;
      if (typeof xmodel.onvalidate != 'undefined') xmodel.onvalidate(xmodel, function (rslt) { valid = (rslt === true); done(); });
      else done();
    }, function () {
      if (!valid) return options.onFail('form_validation');
      //Run save API operation
      XPage.Save_Operation(dbtasks,options);
    }, { series: true });
  }

  XPage.Save_Operation = function(dbtasks, options) {
    if (!options) options = {};
    if (!options.onFail) options.onFail = function () { };
    var rootxmodel = jsh.XModels[jsh.XModels_root];
    //Execute API transaction of all database tasks
    rootxmodel.controller.form.ExecuteTrans(dbtasks, function (rslt) {
      //On successful API call
      if (options.onComplete && (options.onComplete(rslt) === false)) return;
      //Run the "SaveComplete" handler on each model (restore unbound fields)
      for(var modelid in jsh.XModels){
        var xmodel = jsh.XModels[modelid];
        if(xmodel.unbound) continue;
        var dbrsltsuffix = '_'+modelid;
        var modelrslt = {};
        for(var dbrslt in rslt){
          if(XExt.endsWith(dbrslt,dbrsltsuffix)){
            modelrslt[dbrslt] = rslt[dbrslt];
          }
        }
        if(xmodel.controller.SaveComplete){
          xmodel.controller.SaveComplete(modelrslt);
        }
      }
      //On successful insert operation
      //Navigate to a new URL with the new keys in the querystring
      if (jsh.is_insert) {
        var url = XExt.currentURL() + '?action=update';
        var urlkeys = {};
        //Scan results for key
        _.each(rootxmodel.keys, function (key) {
          //Find keys in results
          var foundkey = false;
          _.each(rslt, function (mrslt, modelid) {
            if (_.isObject(mrslt)) {
              if (key in mrslt) {
                var keyval = mrslt[key];
                if(!rootxmodel.bindings) rootxmodel.bindings = {};
                rootxmodel.bindings[key] = function () { return keyval; }
                rootxmodel.controller.form.Data[key] = keyval;
                urlkeys[key] = keyval;
                foundkey = true;
              }
            }
          });
          if (!foundkey) urlkeys[key] = rootxmodel.getBindingOrRootKey(key);
        });
        jsh.is_insert = false;
        if (!_.isEmpty(urlkeys)) url = url + '&' + $.param(urlkeys, false);
        window.onbeforeunload = null;
        jsh.cancelExit = true;
        //Execute oninsert Handler
        var bubble = true;
        XPage.traverseModels(null, function (xmodel) {
          if (!bubble) return;
          if (typeof xmodel.oninsert != 'undefined') if (xmodel.oninsert(xmodel, urlkeys, url) === false) bubble = false;
        });
        if (!bubble) return;

        //Refresh any parent form
        XPage.RefreshParent();

        //Refresh the page to load the "update" form
        XExt.navTo(url);

        return;
      }

      //On successful update operation
      //Execute onupdate Handler
      var bubble = true;
      XPage.traverseModels(null, function (xmodel) {
        if (!bubble) return;
        if (typeof xmodel.onupdate != 'undefined') if (xmodel.onupdate(xmodel) === false) bubble = false;
      });
      if (!bubble) return;

      console.log('Save complete');
      //Refresh any parent form
      XPage.RefreshParent();
      //Refresh the database data
      XPage.Select({ force: true }, function () {
        console.log('Reselect complete');
      });
    }, options.onFail);
  }

  XPage.SaveNew = function(onComplete, options) {
    options = _.extend({ abortRefresh: false },options);
    XPage.Save({
      onComplete: function () {
        XPage.RefreshParent();
        if(options.abortRefresh){
          window.onbeforeunload = null;
          jsh.cancelExit = true;
        }
        if(onComplete) onComplete();
        if(options.abortRefresh) return false;
      }
    });
  }

  XPage.Delete = function() {
    if(!jsh.XModels_root){ XExt.Alert('No root model configured'); return; }

    var xmodel = jsh.XModels[jsh.delete_target];
    xmodel.controller.Delete(function () {
      XPage.RefreshParent();
      var xparent = jsh.XModels[xmodel.parent];

      //If the form is not the root form, and the parent binding field is unbound and editable, then just refresh the parent
      if((xmodel.id != jsh.XModels_root) && xmodel.bindings && xparent){
        var editable_parent_bindings = false;
        _.each(xmodel.binding_fields, function(parent_field, child_field){
          var field = xparent.fields[parent_field];
          if(field && field.unbound && XExt.hasAction(field.actions, 'U')) editable_parent_bindings = true;
        });
        //Reload parent model, resetting defaults on bound fields
        if(editable_parent_bindings){
          _.each(xmodel.binding_fields, function(parent_field, child_field){
            for(var key in xparent.unbound_data){
              if(parent_field in xparent.unbound_data[key]) delete xparent.unbound_data[key][parent_field];
            }
          });
          XPage.Select({ force: true });
          return;
        }
      }

      //Otherwise, close the form, navigate up the breadcrumbs, or go to the root URL
      window.onbeforeunload = null;
      jsh.cancelExit = true;
      if (jsh.is_popup) {
        if (window.opener) {
          window.close();
        }
        else {
          //window.open('', '_parent', '');  //Possibly needed for firefox
          window.close();
        }
      }
      else {
        var target = jsh._BASEURL;
        var bcrumbobj = jsh.$root('div.bcrumbs');
        if (bcrumbobj.size() > 0) {
          target = bcrumbobj.children('a').last().prop('href');
        }
        XExt.navTo(target);
      }
    });
  }

  XPage.RenderButtons = function(oroot){
    if(!oroot) oroot = jsh.root;
    var button_groups = {};
    //Merge buttons in tab containers with tabpos="top" with tab
    XPage.traverseModels(null, function (xmodel) {
      if(xmodel.curtab && (xmodel.tabpos=='top')){
        var childModel = jsh.XModels[xmodel.curtab];
        var parentactions = $('.xactions.xelem'+xmodel.class);
        var childactions = $('.xactions.xelem'+childModel.class);
        if(childactions.length && parentactions.length){
          if(!XExt.hasAction(xmodel.actions, 'IU')){
            parentactions.children().appendTo(childactions);
            parentactions.remove();
          }
        }
      }
    });
    $(oroot).find('.xform_button').each(function () {
      var jbtn = $(this);
      var btnactions = jbtn.data('actions');
      if (jsh.is_insert && !XExt.hasAction(btnactions, 'I')) jbtn.hide();
      else {
        if(jbtn.hasClass('grouped')){
          var modelid = jbtn.data('model');
          var buttonmodel = jsh.XModels[modelid];
          var group = jbtn.data('group');
          var button_group_name = modelid+'_'+group;
          if(!(button_group_name in button_groups)) button_groups[button_group_name] = {
            modelid: modelid,
            modelclass: buttonmodel.class,
            group: group,
            jbutton: []
          };
          button_groups[button_group_name].jbutton.push(jbtn);
        }
      }
    });
    for(var button_group_name in button_groups){
      var button_group = button_groups[button_group_name];
      jsh.$root('.xbody').append('<div class="xactions_group xcontext_menu xelem'+button_group.modelclass+'" data-group="'+button_group.group+'" style="display:none;"></div>');
      var jgroup = jsh.$root('.xactions_group.xelem'+button_group.modelclass+'[data-group="'+button_group.group+'"]');
      _.each(button_group.jbutton,function(jbutton){
        jgroup.append(jbutton);
      });
    }
  }

  XPage.onReady = function() {
    if(!jsh.XModels_root){ XExt.Alert('No root model configured'); return; }

    XPage.Hide(null,function(xmodel){ return xmodel.layout=='grid'; });
    if (!jsh.XModels[jsh.XModels_root].actions) { XExt.Alert('ERROR - No effective access to root form'); return; }

    var enable_save = false;
    var enable_delete = false;
    XPage.traverseModels(null, function (xmodel) {
      if ((xmodel.layout == 'form') || (xmodel.layout == 'multisel') || (xmodel.layout == 'form-m')) {
        if (XExt.hasAction(xmodel.actions, 'IU') && !xmodel.unbound) enable_save = true;
        if ((xmodel.id == jsh.XModels_root) || (xmodel.parent == jsh.XModels_root))
          if (!enable_delete && XExt.hasAction(xmodel.actions, 'D')) { enable_delete = true; jsh.delete_target = xmodel.id; }
      }
      else if ((xmodel.layout == 'grid') && (xmodel.commitlevel) && (xmodel.commitlevel != 'none')) {
        if (XExt.hasAction(xmodel.actions, 'IUD') && !xmodel.unbound) enable_save = true;
      }
    });

    XPage.traverseModelsAsync(jsh.XModels_root,
      function (xmodel, done) {
        xmodel.controller.Init(done);
      },
      function () {
        if ('state' in jsh._GET) XPage.LoadState(JSON.parse(jsh._GET.state));
        XPage.RenderButtons();
        XPage.traverseModels(null, function (xmodel) {
          if (typeof xmodel.oninit != 'undefined') xmodel.oninit(xmodel);
        });
        
        XPage.Select({ modelid: jsh.XModels_root, force: true }, function () {
          var rootmodel = jsh.XModels[jsh.XModels_root];
          jsh.InitControls();
          XPage.LayoutOneColumn();
          XPage.Show();
          jsh.XWindowResize();
          if (enable_save && !_.includes(rootmodel.hide_system_buttons,'save')) jsh.$root('.xactions .save.top').show();
          if (enable_delete && !_.includes(jsh.XModels[jsh.delete_target].hide_system_buttons,'delete')) jsh.$root('.xactions .delete.top').show();
          XPage.traverseModels(null, function (xmodel) {
            if (!jsh.is_insert && XExt.hasAction(xmodel.actions, 'I')) jsh.$root('.xactions .duplicate.xelem' + xmodel.class).show();
          });
          
          //Update Browser History with URL/state
          if (XExt.isSinglePage()) {
            var new_url = jsh.state.fullpath + jsh.state.QS + jsh.state.hash;
            XExt.ReplaceHistory(new_url, XPage.GetState(new_url));
            if (jsh.state.hash) {
              XExt.jumpAnchor(jsh.state.hash);
            }
          }
          else XExt.ReplaceHistory(window.location.href.toString(), XPage.GetState());

          //Focus on the first element on the page
          var firstControl = jsh.$root('input,select,textarea,.xlookup').not('input[type=hidden]').not('[readonly]').filter(':visible').first();
          if(firstControl && firstControl.length && !firstControl.is('.datepicker')) firstControl.focus();

          //Select first search value by default, if form is open
          var firstSearchValue = jsh.$root('.xsearch_value:visible').first();
          if(firstSearchValue && firstSearchValue.length && !firstSearchValue.hasClass('datepicker')) firstSearchValue.select().focus();

          jsh.init_complete = true;

          var loadTime = ((Date.now()-jsh.pageStartTime)/1000).toFixed(2);
          console.log('Initialization Complete ' + loadTime + 's');
        });
      });
  }

  XPage.Refresh = function(modelid) {
    modelid = XExt.resolveModelID(modelid);
    console.log('Refresh');
    //Handle modelid
    if (XPage.onGridExit(null, function () { XPage.Refresh(modelid); })){
      if(!document.hasFocus()) $(document.activeElement).blur();
    }
    //Modify grid refresh to load multiple pages
    var foundchanges = XPage.GetChanges();
    if (foundchanges.length > 0) return;

    XPage.Select({ modelid: modelid, force: true }, function () { XPage.RefreshParent(); console.log('Reselect complete'); });
  }

  XPage.RefreshParent = function() {
    var jshOpener = XExt.getOpenerJSH(['Refresh']);
    if (jshOpener) {
      jshOpener.XPage.Refresh();
    }
  }

  XPage.Reload = function(options) {
    options = _.extend({ force: false, browserRefresh: false }, options);
    var a = XExt.getURLObj(window.location.href);
    var qs = XExt.parseGET(a.search);
    qs.tstmp = Date.now();
    a.search = '?' + $.param(qs);
    if(options.force){
      window.onbeforeunload = null;
      jsh.cancelExit = true;
    }
    if(options.browserRefresh){
      window.location = a.href.toString();
    }
    else {
      XExt.navTo(a.href.toString());
    }
  }

  XPage.PreDestroy = function() {
    //Call OnDestroy Handlers
    _.each(jsh.XModels, function (xmodel) {
      if (xmodel.controller && xmodel.controller.OnDestroy) xmodel.controller.OnDestroy();
      if (typeof xmodel.ondestroy != 'undefined') xmodel.ondestroy(xmodel);
    });
    //Clear CKEDITORs
    if ((typeof window.CKEDITOR != 'undefined') && (window.CKEDITOR.instances)) {
      for (var name in window.CKEDITOR.instances) {
        window.CKEDITOR.instances[name].destroy();
      }
    }
  }

  XPage.Destroy = function() {
    jsh.trigger('jsh_pageDestroy');
    XPage.unbindEvents();
    for(var key in jsh.App){
      var elem = jsh.App[key];
      if (elem instanceof jsh.XGrid) elem.Destroy();
      delete jsh.App[key];
    }
    for (var i = 0; i < jsh.intervals.length; i++) {
      try { window.clearInterval(jsh.intervals[i]); } catch (e) { }
    }
    jsh.App = {};
    jsh.intervals = [];
    XPage.bindEvents();
  }

  XPage.bindEvents = function() {
    jsh.on('jsh_ready', function(){ XPage.onReady(); });
    jsh.on('jsh_message', function(event, data){ if(data=='jsharmony:refresh') XPage.Refresh(); });
    //jsh.on('jsh_mouseDragBegin', function(event, mouseDragObj, origEvent){ });
    //jsh.on('jsh_mouseDrag', function(event, mouseDragObj, targetObj, origEvent){ });
    //jsh.on('jsh_mouseDragEnd', function(event, mouseDragObj, targetObj, origEvent){ });
  }

  XPage.unbindEvents = function() {
    jsh.off('jsh_ready');
    jsh.off('jsh_message');
    jsh.off('jsh_pageDestroy');
    jsh.off('jsh_mouseDragBegin');
    jsh.off('jsh_mouseDrag');
    jsh.off('jsh_mouseDragEnd');
  }

  XPage.traverseModelDefinitions = function(model,modelParent,modelEach,onComplete,options){ //modelcb(model,modelParent)
    if(!options) options = { ignoreFields: false, ignoreTabs: false };
    if(!model) return;
    modelEach(model,modelParent);
    if(!options.ignoreTabs && model.curtabmodel) XPage.traverseModelDefinitions(model.curtabmodel,model,modelEach,undefined,options);
    if(!options.ignoreFields && model.fields) for(var i=0;i<model.fields.length;i++){
      if(model.fields[i].model) XPage.traverseModelDefinitions(model.fields[i].model,model,modelEach,undefined,options);
    }
    if(onComplete) onComplete();
  }

  //Calling XPage.Select with a null root model will check the model definition for updates
  //Options
  //  modelid : The root modelid that will be loaded.  Default to the root model
  //  onCancel : Function to run when the Select has been canceled due to unsaved changes.
  //  force : (Default false) - Do not check for changes before running .Select
  XPage.Select = function(options, callback) {
    if(_.isString(options)) options = { modelid: options };
    options = _.extend({ modelid: undefined, onCancel: undefined, force: false }, options);
    if(!options.force){
      if(XPage.HasEditableModel(options.modelid)){
        if(!options.onCancel){
          return XExt.Alert('XPage.Select requires either options.force or options.onCancel when a target model or subform is editable (with "I" or "U" actions).\r\n\r\nIf XPage.Select was triggered by a bound field change, the options.onCancel property should undo the change to any bound fields.');
        }
        else{
          return XPage.CheckChanges(options.modelid, function(){ XPage.Select(_.extend(options, { force: true }), callback); }, options.onCancel);
        }
      }
    }
    var rootid = XExt.resolveModelID(options.modelid);
    if(!callback) callback = function(){};
    //Reset models that are disabled due to missing record
    XPage.traverseModels(rootid, function (xmodel) {
      if(xmodel.flags.no_form_record) xmodel.flags.no_form_record = false;
    }, { disabledModels: true });
    //If the Model itself is dynamic, reload the model definition before reloading the data
    if (typeof rootid == 'undefined'){
      var isDynamic = false;
      XPage.traverseModelDefinitions(jsh.cur_model, null, function (model, modelParent) {
        if(model.modeltype=='dynamic') isDynamic = true;
      });
      if(isDynamic) return jsh.Load({ addHistory: false, onRefreshNoChange: function(){ XPage.Select(_.extend(options, { modelid: jsh.XModels_root }), callback); } });
      else rootid = jsh.XModels_root;
    }
    //Call Select on each model
    XPage.traverseModelsAsync(rootid,
      function (xmodel, done) {
        var onDone = function () {
          if (typeof xmodel.onloadimmediate != 'undefined') xmodel.onloadimmediate(xmodel);
          done();
        };
        if (jsh.is_insert){
          if(!XExt.hasAction(xmodel.actions, 'I')) { 
            if((xmodel.layout == 'form') || (xmodel.layout == 'form-m') || (xmodel.layout == 'grid')){
              if(!XExt.hasAction(xmodel.actions, 'B')) return done();
              //If model bindings are dependent on key
              if(xmodel.bindings && (_.keys(xmodel.bindings).length != xmodel.constant_bindings.length)){ XPage.DisableModelControls(xmodel); return done(); }
              //If this is a form with a missing key
              for(var key in xmodel.keys){
                if(xmodel.constant_bindings.indexOf(key)<0){ XPage.DisableModelControls(xmodel); return done(); }
              }
            }
          }
        }
        if(xmodel.unbound && !xmodel._sysconfig.unbound_meta) return onDone();
        xmodel.controller.Select(function(){
          if((xmodel.layout=='form') && !jsh.is_insert && xmodel.controller.form && xmodel.controller.form.Data && xmodel.controller.form.Data._is_insert) xmodel.flags.no_form_record = true;
          return onDone();
        });
      },
      function () {
        //Update title and other dynamic elements with in-place EJS
        XPage.RenderEJS(function () {
          //Initialize htmlareas, if applicable
          XPage.traverseModelsAsync(jsh.XModels_root, function (xmodel, done) {
            async.eachSeries(xmodel.fields, function(field, field_cb){
              if(field.control=='htmlarea') return XExt.CKEditor(xmodel.class+'_'+field.name, (field.controlparams?field.controlparams.htmlarea_config:undefined), field_cb);
              else return field_cb();
            }, done);
          }, function(){
            //Trigger the onload event for each model
            var bubble = true;
            XPage.traverseModels(null, function (xmodel) {
              if (!bubble) return;
              //Run onload
              if (typeof xmodel.onload != 'undefined') if (xmodel.onload(xmodel, callback) === false) bubble = false;
            });
            if (bubble && callback) callback();
            if (XExt.isSinglePage()) jsh.ResetLinks();
          });
        });
      });
  }

  XPage.UpdateWindowTitle = function(options){
    options = _.extend({ resolveEJS: true }, options);

    //If Title = blank, pull title from Tabs
    var xmodel = jsh.XModels[jsh.XModels_root];
    var window_title = '';
    //Apply child tab's title to window if the form's title is blank
    while(!window_title && xmodel){
      if(xmodel.title){
        window_title = xmodel.title||'';
        if(!options.resolveEJS && (window_title.indexOf('<#') >= 0)) return;
        if(window_title && (window_title.indexOf('<#') >= 0)){
          window_title = XPage.ParseEJS(window_title,xmodel.id);
        }
        window_title = XExt.StripTags(window_title).trim();
      }
      xmodel = jsh.XModels[xmodel.curtab];
    }
    if(!window_title) window_title = jsh.XModels_root;
    document.title = XExt.StripTags(jsh.title.replace('%%%PAGETITLE%%%',window_title));
  }

  XPage.UpdateTitle = function(options){
    if(!jsh.XModels_root) return;
    
    XPage.UpdateWindowTitle(options);

    var root_title = jsh.XModels[jsh.XModels_root].title;
    if(root_title && (root_title.indexOf('<#') >= 0)){
      root_title = XPage.ParseEJS(root_title, jsh.XModels_root);
    }
    jsh.$root('.xform_title').html(root_title);
    jsh.$root('.xform_title').toggle(!!root_title);
  }

  XPage.RenderEJS = function(onComplete) {
    //Get breadcrumbs
    if(jsh.XModels_root){
      var rootxmodel = jsh.XModels[jsh.XModels_root];
      if (rootxmodel.controller.HasBreadCrumbs()) jsh.bcrumbs = rootxmodel.controller.GetBreadCrumbs();
    }

    //Check for new titles in returned data
    XPage.traverseModels(null, function(xmodel) {
      if(!xmodel.controller) return;
      if(!xmodel.controller.HasTitle()) return;
      var title = xmodel.controller.GetTitle();
      if(title===null) return;
      title = title||'';
      if(title != xmodel.title){
        xmodel.title = title;
      }
    });

    //Update title
    XPage.UpdateTitle();

    //Update Breadcrumbs
    if (jsh.XModels_root && (jsh.orig_bcrumbs.indexOf('<#') >= 0)) {
      jsh.$root('div.bcrumbs').html(XPage.ParseEJS(jsh.orig_bcrumbs, jsh.XModels_root));
    }

    XPage.traverseModels(null, function (xmodel) {
      jsh.$root(".xtitle.xelem" + xmodel.class).each(function () {
        //Update each form title
        var title_text = xmodel.title;
        if (title_text.indexOf('<#') >= 0) $(this).html(XPage.ParseEJS(title_text, xmodel.id));
        else $(this).html(title_text);
      });
      jsh.$root(".xform_button.xelem" + xmodel.class+', .xnorecords.xelem'+xmodel.class+' a').each(function () {
        var href = $(this).attr('href');
        //Store / retrieve original URL
        if ($(this).data('orighref')) href = $(this).data('orighref');
        else $(this).data('orighref', href);
        //Parse URL EJS
        if (href.indexOf('<#') >= 0) {
          /* Resolve EJS */
          $(this).attr('href', XPage.ParseEJS(href, xmodel.id, xmodel.parent));
        }
      });
    }, { disabledModels: true }, onComplete);
  }

  XPage.RemoveEJSTags = function(jobj) {
    if (jobj.size() == 0) return '';
    var rslt = XPage.getObjEJS(jobj);
    if (rslt.indexOf('<#') >= 0) {
      //jobj.html(rslt.replace(/<#(.*?)#>/g,''));
      jobj.html('');
    }
    return rslt;
  }

  XPage.getObjEJS = function(jobj) {
    if (jobj.size() == 0) return '';
    var rslt = jobj.html();
    rslt = XExt.ReplaceAll(rslt, '&lt;#', '<#');
    rslt = XExt.ReplaceAll(rslt, '#&gt;', '#>');
    return rslt;
  }

  XPage.traverseModels = function(rootid, f, options, oncomplete) {
    rootid = XExt.resolveModelID(rootid);
    options = _.extend({ disabledModels: false }, options);
    
    if(rootid in jsh.XModels){
      //Ignore disabled models
      if (!options.disabledModels && !jsh.XModels[rootid].isEnabled()) return;
      //Run function
      f(jsh.XModels[rootid]);
    }
    //Execute for each child
    _.each(jsh.XModels, function (xmodel, xmodelid) {
      if (xmodel.parent == rootid) {
        XPage.traverseModels(xmodel.id, f, options);
      }
    });
    if (oncomplete) oncomplete();
  }

  XPage.traverseModelsAsync = function(rootid, xmodelfunc, done, options) {
    rootid = XExt.resolveModelID(rootid);
    if (!options) options = { };
    var traverseChildren = function () {
      XPage.traverseModelsAsyncWorker(rootid, xmodelfunc, done, options);
    };
    if(rootid in jsh.XModels) xmodelfunc(jsh.XModels[rootid], traverseChildren);
    else traverseChildren();
  }

  XPage.traverseModelsAsyncWorker = function(parentmodelid, xmodelfunc, done, options) {
    parentmodelid = XExt.resolveModelID(parentmodelid);
    if(!options) options = { disabledModels: false, series: false };

    var childf = [];
    _.each(jsh.XModels, function (xmodel, xmodelid) {
      if (!options.disabledModels && !xmodel.isEnabled()){ return; }
      if (xmodel.parent == parentmodelid) {
        childf.push(function (cb) {
          xmodelfunc(xmodel, function () { XPage.traverseModelsAsyncWorker(xmodel.id, xmodelfunc, cb, options); });
        });
      }
    });

    if (childf.length == 0) { return done(); }

    if (options.series) jsh.async.series(childf, done);
    else jsh.async.parallel(childf, done);
  }

  XPage.getBreadcrumbs = function(){
    var rslt = {};
    for(var modelid in jsh.XModels){
      var xmodel = jsh.XModels[modelid];
      if(xmodel.controller){
        var bcrumbs = xmodel.controller.GetBreadCrumbs();
        if(bcrumbs) rslt = _.extend(rslt, bcrumbs);
      }
    }
    if(jsh.XModels_root){
      var rootxmodel = jsh.XModels[jsh.XModels_root];
      if(rootxmodel.controller && rootxmodel.controller.HasBreadCrumbs()){
        rslt = _.extend(rslt, jsh.bcrumbs);
      }
    }
    return rslt;
  }

  XPage.ParseEJS = function(_ejssrc, modelid, parentmodelid, data) {
    modelid = XExt.resolveModelID(modelid);
    parentmodelid = XExt.resolveModelID(parentmodelid);
    var ejssrc = _ejssrc;
    data = _.extend({}, data);
    if (!(modelid in jsh.XModels)) { XExt.Alert('Error: Model ' + modelid + ' not found.'); return; }
    var xmodel = jsh.XModels[modelid];
    var xparentmodel = null;
    _.merge(data, jsh.forcequery);
    if(parentmodelid){
      xparentmodel = jsh.XModels[parentmodelid];
      if(xparentmodel.controller && xparentmodel.controller.grid) _.merge(data, xparentmodel.controller.grid.Data);
      else if(xparentmodel.controller && xparentmodel.controller.form) _.merge(data, xparentmodel.controller.form.Data);
    }
    if(xmodel.controller && xmodel.controller.grid) _.merge(data, xmodel.controller.grid.Data);
    else if(xmodel.controller && xmodel.controller.form) _.merge(data, xmodel.controller.form.Data);
    
    if(parentmodelid){
      for(var fieldname in xparentmodel.bindings){
        data[fieldname] = xparentmodel.bindings[fieldname]();
      }
    }
    for(var fieldname in xmodel.bindings){
      data[fieldname] = xmodel.bindings[fieldname]();
    }
    ejssrc = ejssrc.replace(/<#/g, '<' + '%').replace(/#>/g, '%' + '>');

    var ejsrslt = jsh.ejs.render(ejssrc, {
      data: data,
      LiteralOrLookup: XExt.LiteralOrLookup,
      bcrumbs: XPage.getBreadcrumbs(),
      jsh: jsh,
      instance: jsh.getInstance(),
      _GET: jsh._GET,
      modelid: modelid,
      xmodel: xmodel,
      _this: jsh.App[modelid],
      js: function(code,options){ return XExt.wrapJS(code,modelid,options); }
    });
    return ejsrslt;
  }

  XPage.LayoutOneColumn = function(oroot, options){
    if(!oroot) oroot = jsh.root;
    options = _.extend({ reset: false }, options);
    $(oroot).find('.xform.onecolumn').each(function(){
      var jform = $(this);
      var max_width = 0;
      if(options.reset){
        jform.find('.leading').each(function(){ 
          var jobj = $(this);
          if(jobj.closest('.xform')[0]!=jform[0]) return;
          jobj.css('width','auto');
        });
      }
      jform.find('.leading').each(function(){ 
        var jobj = $(this);
        if(jobj.closest('.xform')[0]!=jform[0]) return;
        var width = jobj.width(); 
        if(width > max_width) max_width = width;
      });
      jform.find('.leading').each(function(){ 
        var jobj = $(this);
        if(jobj.closest('.xform')[0]!=jform[0]) return;
        jobj.width(max_width);
        if(jobj.is(':visible')) jobj.toggle((max_width>0));
      });
    });
  }
  
  XPage.Hide = function(modelid,cond) {
    modelid = XExt.resolveModelID(modelid);
    _.each(jsh.XModels, function (xmodel, xmodelid) {
      if(modelid && (modelid!=xmodelid)) return;
      if(cond && !cond(xmodel)) return;
      if (xmodel.layout == 'grid') jsh.$root('.xtbl.xelem' + xmodel.class + ',.xbodyhead.xelem' + xmodel.class).hide();
      else {
        jsh.$root('.xform'+xmodel.class).hide(); 
        jsh.$root('.xtabcontrol'+xmodel.class).hide(); 
      }
    });
  }

  XPage.Show = function(modelid, cond) {
    modelid = XExt.resolveModelID(modelid);
    _.each(jsh.XModels, function (xmodel, xmodelid) {
      if(modelid && (modelid!=xmodelid)) return;
      if(cond && !cond(xmodel)) return;
      if (xmodel.layout == 'grid') jsh.$root('.xtbl.xelem' + xmodel.class + ',.xbodyhead.xelem' + xmodel.class).show();
      else {
        jsh.$root('.xform' + xmodel.class).show();
        jsh.$root('.xtabcontrol' + xmodel.class).show();
      }
    });
  }

  XPage.GetState = function(url) {
    var rslt = {};
    _.each(jsh.XModels, function (xmodel) {
      if (!xmodel.isEnabled()) return;
      if (!XExt.hasAction(xmodel.actions, 'B')) return;
      if (xmodel.ongetstate){ rslt[xmodel.id] = xmodel.ongetstate(xmodel); return; }
      if (xmodel.layout != 'grid') return;
      rslt[xmodel.id] = xmodel.controller.GetState();
    });
    if ((typeof url != 'undefined') && (url != '')) rslt['_url'] = url;
    return rslt;
  }

  XPage.AddHistory = function(new_jsh_state, use_cur_state, options) {
    options = _.extend({ replaceHistory: false }, options);
    //Add Full URL to history (PATH+GET+HASH)
    var url = '';
    var state = undefined;
    if ((typeof new_jsh_state != 'undefined') && new_jsh_state) {
      url = new_jsh_state.fullpath + new_jsh_state.QS + new_jsh_state.hash;//$.param(JSON.parse(JSON.stringify(new_jsh_state.GET)));
      jsh.cur_history_url = url;
      if (use_cur_state) state = XPage.GetState(jsh.cur_history_url);
    }
    else {
      url = window.location.href.toString().split(window.location.host)[1];
      url = url.split('?')[0];
      url = url.split('#')[0];
      var nget = JSON.parse(JSON.stringify(jsh._GET));

      state = XPage.GetState(jsh.cur_history_url);
      var nget_state = JSON.parse(JSON.stringify(state));
      if ('_url' in nget_state) delete nget_state._url;

      nget.state = JSON.stringify(nget_state);
      if (!_.isEmpty(nget)) url += '?' + $.param(nget);
      state._url = url;
    }
    if(options.replaceHistory) XExt.ReplaceHistory(url, state);
    else XExt.AddHistory(url, state);
  }

  XPage.LoadState = function(state, options) {
    if(!options) options = { addBackHistoryOnCancel: false, _GET: undefined };
    if (!_.isObject(state)) return;

    if(typeof options._GET != 'undefined') jsh._GET = options._GET;

    if ('_url' in state) {
      //Get Base URL (PATH+GET)
      //var base_url = a.pathname + a.search;

      if (state._url != jsh.cur_history_url) {
        jsh._GET.state = JSON.stringify(state);
        var a = XExt.getURLObj(state._url);
        var orig_a = XExt.getURLObj(jsh.cur_history_url);
        var orig_url = orig_a.pathname + orig_a.search;
        jsh.cur_history_url = state._url;
        jsh.Navigate(a, false, orig_url, function () {
          if (options.addBackHistoryOnCancel) {
            XPage.AddHistory(jsh.state, true);
          }
        }, { force: true });
        return false;
      }
    }
    _.each(jsh.XModels, function (xmodel) {
      XPage.LoadModelState(xmodel, state[xmodel.id]);
    });
    if ('state' in jsh._GET) delete jsh._GET.state;
    return true;
  }

  XPage.LoadModelState = function(xmodel, modelstate){
    var modelid = xmodel.id;
    if (!xmodel.isEnabled()) return;
    if (!XExt.hasAction(xmodel.actions, 'B')) return;
    if (xmodel.onloadstate) return xmodel.onloadstate(xmodel, modelstate);
    if (xmodel.layout != 'grid') return;
    if (typeof modelstate != 'undefined') xmodel.controller.LoadState(modelstate);
  }

  XPage.DownloadFile = function(modelid, field, title) {
    modelid = XExt.resolveModelID(modelid);
    var xmodel = jsh.XModels[modelid];
    var jctrl_token = jsh.$root('.xelem' + xmodel.class + ' .' + field + '_token');
    var file_token = jctrl_token.val();
    var url = '';
    if (file_token) url = jsh._BASEURL + '_dl/_temp/' + file_token;
    else {
      var xmodel = jsh.XModels[modelid];
      var keys = xmodel.controller.form.GetKeys();
      if (xmodel.keys.length != 1) { throw new Error('File models require one key.'); }
      url = jsh._BASEURL + '_dl/' + modelid + '/' + keys[xmodel.keys[0]] + '/' + field;
    }
    jsh.getFileProxy().prop('src', url);
  }

  XPage.FilePreview = function(modelid, field, title) {
    modelid = XExt.resolveModelID(modelid);
    var xmodel = jsh.XModels[modelid];
    var jctrl_token = jsh.$root('.xelem' + xmodel.class + ' .' + field + '_token');
    var file_token = jctrl_token.val();
    var url = '';
    if (file_token) url = jsh._BASEURL + '_dl/_temp/' + file_token + '?view=1';
    else {
      var xmodel = jsh.XModels[modelid];
      var keys = xmodel.controller.form.GetKeys();
      if (xmodel.keys.length != 1) { throw new Error('File models require one key.'); }
      url = jsh._BASEURL + '_dl/' + modelid + '/' + keys[xmodel.keys[0]] + '/' + field + '?view=1';
      url += '&_=' + (Date.now());
    }
    window.open(url,'_blank',"height=600, width=800"); 
  }

  XPage.FileDelete = function(modelid, fieldname, title) {
    modelid = XExt.resolveModelID(modelid);
    var xmodel = jsh.XModels[modelid];
    var jctrl_token = jsh.$root('.xelem' + xmodel.class + ' .' + fieldname + '_token');
    var jctrl_dbexists = jsh.$root('.xelem' + xmodel.class + ' .' + fieldname + '_dbexists');
    var jctrl_dbdelete = jsh.$root('.xelem' + xmodel.class + ' .' + fieldname + '_dbdelete');
    var jctrl = jsh.$root('.' + fieldname + '.xelem' + xmodel.class);
    if (jctrl_dbexists.val() == '1') jctrl_dbdelete.val('1');
    jctrl_token.val('');
    jctrl.addClass('nodocument');
    XExt.setFormControl(xmodel.controller.form, fieldname, '');
  }

  XPage.FileUploadDialog = function(modelid, fieldname, title) {
    modelid = XExt.resolveModelID(modelid);
    var xmodel = jsh.XModels[modelid];
    var field = xmodel.fields[fieldname];
    //Get PrevToken, if Applicable
    jsh.xfileupload_ctrl = jsh.$root('.' + fieldname + '.xelem' + xmodel.class);
    if (jsh.xfileupload_ctrl.size() != 1) return;
    $.colorbox({
      href: jsh.$root(".xfileuploader"), inline: true, closeButton: false, arrowKey: false, preloading: false, overlayClose: false, title: title, fixed: true,
      onOpen: function () {
        jsh.$root('.xfileuploader_prevtoken').val(jsh.xfileupload_ctrl.children('.xform_file_token').val());
        jsh.$root('.xfileuploader_form').attr('action', jsh._BASEURL + '_ul/');
        XExt.clearFileInput(jsh.$root('.xfileuploader_file')[0]);
      },
      onComplete: function () { /* Optionally set element focus */ }
    });
  }

  XPage.FileUploadSubmit = function() {
    //Validate file selected
    if (!jsh.$root(".xfileuploader_file").val()) { XExt.Alert('Please select a file and then click Upload.'); return; }
    jsh.xLoader.StartLoading(jsh.xfileuploadLoader)
    //Submit form
    jsh.$root('.xfileuploader_form').submit();
    //Associate file_token, prevtoken with single field
    //Submit that field to the server on update/insert
  }

  XPage.FileUploadComplete = function(rslt) {
    $.colorbox.close();
    if (!('file_token' in rslt)) return;
    jsh.xfileupload_ctrl.children('.xform_file_token').val(rslt.file_token);
    jsh.xfileupload_ctrl.children('.xform_file_dbdelete').val('0');
    jsh.xfileupload_ctrl.removeClass('nodocument');
    //Rerender Control
    var val = XExt.getFormField(XExt.getFormFromObject(jsh.xfileupload_ctrl), jsh.xfileupload_ctrl.data('id'));
    XExt.setFormControl(XExt.getFormFromObject(jsh.xfileupload_ctrl), jsh.xfileupload_ctrl.data('id'), val);
  }

  XPage.onJSProxyComplete = function(id, data) {
    var _this = this;
    jsh.xLoader.StopLoading(jsh.xfileuploadLoader);
    if ((typeof data) == 'object'){
      if ('_error' in data) {
        if (id in jsh.jsproxy_hooks) { jsh.jsproxy_hooks[id](data._error,null); }
        else if (jsh.DefaultErrorHandler(data._error.Number, data._error.Message)) { }
        else if ((data._error.Number == -9) || (data._error.Number == -5)) { XExt.Alert(data._error.Message); }
        else { XExt.Alert('Error #' + data._error.Number + ': ' + data._error.Message); }
        return;
      }
      else if ('_success' in data) {
        if (id == 'xfileuploader') XPage.FileUploadComplete(data);
        else if (id in jsh.jsproxy_hooks) { jsh.jsproxy_hooks[id](null,data); }
        else XExt.Alert(JSON.stringify(data));
        return;
      }
    }
    XExt.Alert(JSON.stringify(data));
  }

  XPage.RunReport = function() {
    var xmodel = jsh.XModels[jsh.XModels_root];
    if (!(xmodel.layout == 'report')) { XExt.Alert('Root model does not have a "report" layout'); return; }
    xmodel.controller.RunReport();
  }

  XPage.RunReportHTML = function() {
    var xmodel = jsh.XModels[jsh.XModels_root];
    if (!(xmodel.layout == 'report')) { XExt.Alert('Root model does not have a "report" layout'); return; }
    xmodel.controller.RunReport({output:'html'});
  }

  XPage.TestQueue = function() {
    var xmodel = jsh.XModels[jsh.XModels_root];
    if (!(xmodel.layout == 'report')) { XExt.Alert('Root model does not have a "report" layout'); return; }
    xmodel.controller.TestQueue();
  }

  XPage.RunQueue = function() {
    var xmodel = jsh.XModels[jsh.XModels_root];
    if (!(xmodel.layout == 'report')) { XExt.Alert('Root model does not have a "report" layout'); return; }

    XExt.Confirm("Are you sure you want to start the Report Job?", function () {
      xmodel.controller.RunQueue();
    });
  }

  XPage.RunDBFunc = function() { /* (cb), (object, cb), (cb, options), or (object, cb, options) */
    var cb = arguments[0];
    var xmodel = jsh.XModels[jsh.XModels_root];
    var options = {};
    var thisobj = null;
    if(arguments.length==2){
      if(_.isFunction(arguments[1])){
        thisobj = arguments[0];
        cb = arguments[1];
      }
      else if(_.isFunction(arguments[0])){
        cb = arguments[0];
        options = arguments[1];
      }
    }
    else if(arguments.length==3){
      thisobj = arguments[0];
      cb = arguments[1];
      options = arguments[2];
    }
    if(thisobj) xmodel = jsh.XModels[XExt.getModelIdFromObject(thisobj)];
    
    if (!(xmodel.layout == 'exec') && !(xmodel.layout == 'report')) { XExt.Alert('Root model does not have an exec or report layout'); return; }
    xmodel.controller.RunDBFunc(cb, options);
  }

  XPage.DisableModelControls = function(xmodel){
    var isGrid = (xmodel.layout == 'grid');
    if(!xmodel.datamodel) return;
    _.each(xmodel.fields, function(field){
      var fieldselector = '.' + field.name + '.xelem' + xmodel.class;
      if (isGrid) fieldselector = '.' + field.name + '.xelem' + xmodel.class;
      var jctrl = jsh.root.find(fieldselector);
      if(jctrl.length) XPage.Disable(jctrl);
    });
  }

  XPage.Disable = function(jctrls,show_lookup) {
    XExt.jForEach(jctrls, function(jctrl){
      jctrl.removeClass('editable');
      jctrl.addClass('uneditable');

      if (jctrl.hasClass('dropdown')) jctrl.prop('disabled', true);
      else if (jctrl.hasClass('checkbox')) jctrl.prop('disabled', true);
      else if(jctrl.hasClass('xtagbox_base')){
        jctrl.prev().addClass('uneditable');
        jctrl.prev().find('input').prop('disabled', true);
      }
      else jctrl.prop('readonly', true);
      if (!show_lookup && jctrl.next().hasClass('xlookup')) jctrl.next().addClass('uneditable');
    });
  }

  XPage.Enable = function(jctrls) {
    XExt.jForEach(jctrls, function(jctrl){
      jctrl.removeClass('uneditable');
      jctrl.addClass('editable');

      if (jctrl.hasClass('dropdown')) jctrl.prop('disabled', false);
      else if (jctrl.hasClass('checkbox')) jctrl.prop('disabled', false);
      else if(jctrl.hasClass('xtagbox_base')){
        jctrl.prev().removeClass('uneditable');
        jctrl.prev().find('input').prop('disabled', false);
      }
      else jctrl.prop('readonly', false);
      if (jctrl.next().hasClass('xlookup')) jctrl.next().removeClass('uneditable');
    });
  }

  XPage.Print = function() {
    window.print();
  }

  //Clear Popups on Reset
  XPage.PopupCreate = function(onComplete) {
    var popup_id = '';
    do {
      popup_id = 'P' + Math.floor(Math.random() * 100000);
    } while (popup_id in jsh.XPopups);
    jsh.XPopups[popup_id] = onComplete;
    return popup_id;
  }

  XPage.PopupComplete = function(id, rslt) {
    if (!(id in jsh.XPopups)) return;
    jsh.XPopups[id](rslt);
  }

  XPage.onGridExit = function(obj, f) {
    var has_changes = false;
    XPage.traverseModels(null, function (xmodel) {
      if (has_changes) return;
      if ((xmodel.layout == 'grid') && (xmodel.commitlevel) && (xmodel.commitlevel != 'none')) {
        if (xmodel.commitlevel == 'page') {
          if (xmodel.controller.form.IsDirty) {
            XExt.Alert('Please save changes before performing grid operations.');
            has_changes = true;
            return;
          }
        }
        if (xmodel.controller.editablegrid && xmodel.controller.editablegrid.CurrentCell) {
          jsh.queuedInputAction = new XExt.XInputAction(obj, f);
          has_changes = true;
          return;
        }
      }
    });
    return has_changes;
  }

  XPage.openDataURL = function(win, modelid, url, options) {
    modelid = XExt.resolveModelID(modelid);
    var xmodel = jsh.XModels[modelid];
    if (!win) win = window.open('', '_blank', options);
    url = XPage.ParseEJS(url, modelid);
    win.location = url;
    win.focus();
  }

  XPage.promptDuplicate = function(modelid, dclass, dcaption, data){
    var xmodel = jsh.XModels[modelid];
    if(xmodel.controller.form){
      xmodel.controller.form.Reset();
      xmodel.controller.form.Prop.Enabled = true;
    }
    XPage.Select({ modelid: modelid, onCancel: function(){ } }, function(){
      XExt.popupShow(modelid,dclass,dcaption,undefined,data);
    });
  }

  XPage.Duplicate = function(modelid, link, link_options) {
    modelid = XExt.resolveModelID(modelid);
    var win = null;
    var xmodel = jsh.XModels[modelid];
    xmodel.controller.RunDBFunc(function (rslt) {
      //On success
      if(link){
        XPage.openDataURL(win, modelid, link, link_options, rslt);
        win.opener = window.opener;
      }
      XPage.RefreshParent();
      $.colorbox.close();
      XPage.Refresh();
    }, {
      onBeforeUpdate: function () {
        if(link) win = window.open('', '_blank', link_options);
      },
      noMessage: true,
      onFail: function (err) { if(win) win.close(); }
    });
  }
  
  XPage.HasUpdates = function() {
    var rslt = false;
    _.each(jsh.XModels, function (xmodel) {
      if (!xmodel.isEnabled()) return;
      if (!XExt.hasAction(xmodel.actions, 'IUD')) return;
      if (xmodel.controller.HasUpdates()) { rslt = true; }
    });
    return rslt;
  }

  XPage.handleShortcutKeys = function(e) {
    var handled = false;
    if ((e.which == 83) && (e.altKey)) {//ALT+S = SAVE
      jsh.$root('.save:visible').first().trigger('click');
      handled = true;
    }
    else if ((e.which == 78) && (e.altKey)) {//ALT+N = NEW
      XExt.findClosest(e.target, '.xbuttoninsert:visible').first().trigger('click');
      handled = true;
    }
    else if ((e.which == 70) && (e.altKey)) {//ALT+Q = Search
      jsh.$root('.xsearchbutton:visible').first().trigger('click');
      handled = true;
    }
    else if ((e.which == 80) && (e.altKey)) {//ALT+P = PRINT
      XPage.Print();
      handled = true;
    }
    else if ((e.which == 68) && (e.altKey) && (e.ctrlKey)) { //ALT+CTRL+D = ENABLE DEBUG CONSOLE
      jsh.xDebugConsole.toggle();
      handled = true;
    }
    return handled;
  }

  XPage.ShowButtonGroup = function(e,obj){
    var jobj = $(obj);
    var modelid = $(jobj).data('model');
    var group = $(jobj).data('group');
    var xmodel = jsh.XModels[modelid];
    var jgroup = jsh.$root('.xactions_group.xelem'+xmodel.class+'[data-group="'+group+'"]');
    
    var already_open = !!jsh.$root('.xcontext_menu:visible').filter(jgroup).length;
    XExt.HideContextMenu();
    if(already_open) return;
    
    jgroup.css('visibility', 'hidden');
    jgroup.show();
    var xtop = jobj.offset().top + jobj.outerHeight(); var xleft = jobj.offset().left;
    var offset = jgroup.offsetParent().offset();
    xtop -= offset.top + 1;
    xleft -= offset.left;
    jgroup.css({ 'top': xtop, 'left': xleft });
    jgroup.css('visibility', 'visible');
    jsh.xContextMenuVisible = true;
    jsh.xContextMenuItem = modelid;
    XExt.CancelBubble(e);
  }

  XPage.LoadVirtualModel = function(ocontainer, model, cb){
    //Render model as HTML
    var jcontainer = $(ocontainer);
    if(!jcontainer.length) throw new Error('Could not load model: Target container not found');

    XPage.ParseModelDefinition(model, function(err){
      XExt.Alert('Error in model definition '+(model && model.id ? model.id : '')+': '+err.toString());
    }, function(){
      var parent = null;
      if(model.parent) parent = jsh.XModels[model.parent] || null;
      var ejsrslt = jsh.Render(model, parent);
      //CODE_EJSPREPEND is used in top-level forms, to change position of the title
      if(ejsrslt.indexOf(jsh.CODE_EJSPREPEND)>=0) ejsrslt = ejsrslt.replace(jsh.CODE_EJSPREPEND,'');
      if(jcontainer.hasClass('xdialogbox')){
        ejsrslt += '<div style="clear:both;"></div>';
      }
      //Add model to DIV
      jcontainer.html(ejsrslt);

      XPage.traverseModelsAsync(model.id,
        function (xmodel, done) {
          xmodel.controller.Init(function(){
            if(model.id == xmodel.id){
              if(model.rowlimit && xmodel.controller.grid) xmodel.controller.grid.RowLimit = model.rowlimit;
            }
            for(var i=0;i<model.fields.length;i++){
              var field = model.fields[i];
              if(field.name && field.lov && field.lov.values){
                xmodel.controller.setLOV(field.name, XExt.parseLOV(field.lov.values));
              }
            }
            done();
          });
        },
        function () {
          var orig_GET = jsh.XExt.parseGET();
          if ('state' in orig_GET){
            var fullstate = {};
            try{
              fullstate = JSON.parse(orig_GET.state);
            }
            catch(ex){}
            XPage.traverseModels(model.id, function (xmodel) {
              XPage.LoadModelState(xmodel, fullstate[xmodel.id]);
            });
          }
          XPage.RenderButtons(jcontainer);
          XPage.traverseModels(model.id, function (xmodel) {
            if (typeof xmodel.oninit != 'undefined') xmodel.oninit(xmodel);
          });
          XPage.Select({ modelid: model.id, force: true }, function () {
            jsh.ResetLinks();
            jsh.InitControls();
            XPage.LayoutOneColumn(jcontainer);
            jsh.XWindowResize();
            if(cb) return cb(jsh.XModels[model.id]);
          });
        }
      );
    });
  }

  XPage.ParseModelDefinition = function(model, onError, onSuccess){
    if(!onError) onError = function(err){};
    if(!onSuccess) onSuccess = function(){};

    var hasErrors = false;
    var handleError = function(err){ hasErrors = true; onError(err); }

    if(!model) return handleError(new Error('Model not defined'));
    if(!model.id) return handleError(new Error('Model ID is required'));
    if(model.id in jsh.XModels) return handleError(new Error('Another Model with the same ID is already loaded'));
    if(!model.layout) return handleError(new Error('Model layout is required'));
    if(!_.includes(['form','grid'], model.layout)) return handleError(new Error('Model layout must be form or grid'));
    var modelDefaults = {
      namespace: '',
      templates: {},
      actions: 'BIUD',
      breadcrumbs: '',
      module: '',
      module_namespace: '',
      using: [],
      _sysconfig: {},
      buttons: [],
      modeltype: 'static',
      title: '',
      caption: ['','Item','Items'],
      forcequery: {},
      topmost: false,
      ejs: '',
      css: '',
      js: '',
      fields: [],
    };
    if(model.layout=='grid'){
      modelDefaults = _.extend(modelDefaults, {
        rowlimit: 0,
        commitlevel: 'row',
      });
    }
    for(var key in modelDefaults){
      if(!(key in model)) model[key] = modelDefaults[key];
    }
    if(!model.class) model.class = XExt.escapeCSSClass(model.id);
    if(_.isFunction(model.js)) model.js = 'jsh.App[modelid] = new (' + model.js.toString() + ')();';
    if((model.layout=='form') && !('onecolumn' in model)) model.onecolumn = true;

    for(var i=0;i<model.buttons.length;i++){
      var button = model.buttons[i];
      if(button.link && (button.link.substr(0,3)=='js:')){
        button.onclick = "var modelid = '" + XExt.escapeJS(model.id) + "'; "+button.link.substr(3)+'; return false;';
        button.link = '#';
      }
    }

    if(model.css) model.css = XExt.ParseMultiLine(model.css);
    if(model.js) model.js = XExt.ParseMultiLine(model.js);

    var firstfield = true;
    for(var i=0;i<model.fields.length;i++){
      var field = model.fields[i];
      if(field.name && field.type){
        if(!('locked_by_querystring' in field)) field.locked_by_querystring = true;
        if(!('captioncolon' in field)) field.captioncolon = true;
      }
      if(!('actions' in field)){
        if(_.includes(['html','button','linkbutton','file_download','image'], field.control)) field.actions = 'B';
        else field.actions = 'BIU';
      }
      if(!('controlparams' in field)) field.controlparams = {};
      if(field.always_editable) field.actions = 'BIU';
      else field.actions = XExt.xejs.getActions(model.actions, field.actions);
      if(!('control' in field)){
        if(field.value) field.control = 'html';
        else if(XExt.hasAction(field.actions, 'B')) field.control = 'label';
      }
      if(field.validate){
        for(var j=0;j<field.validate.length;j++){
          field.validate[j] = XPage.ParseValidator(field.validate[j], model, field, field.actions);
        }
      }
      if(!('caption' in field) || (typeof field.caption == 'undefined')){
        if(_.includes(['subform','html','hidden'],field.control)) field.caption = '';
        else if(_.includes(['linkbutton','button','label'],field.control) && ('value' in field)){
          if(model.layout=='grid') field.caption = field.value;
          else field.caption = '';
        }
        else if ('name' in field) {
          field.caption = field.name;
        }
      }
      if(_.includes(['linkbutton','button'],field.control) && ('caption' in field) && !('value' in field)) field.value = field.caption;

      //Apply one-column layout
      if(model.onecolumn && !('nl' in field)){
        if((model.layout=='form')||(model.layout=='form-m')||(model.layout=='exec')||(model.layout=='report')){
          if(!firstfield && ('control' in field)){
            if((field.control=='html') && ('value' in field) && !field.caption){ /* No action */ }
            else field.nl = 1;
          }
        }
      }

      //Clear first field flag if no longer the first field
      if(firstfield && field.control && field.actions){
        if(!XExt.hasAction(field.actions, 'BIUD')) { /* No action */ }
        else if(field.control=='hidden') { /* No action */ }
        else if((field.control=='html') && ('value' in field) && !field.caption) { /* No action */ }
        else firstfield = false;
      }
    }

    if(!hasErrors) onSuccess();
  }

  XPage.ParseValidator = function(validator, model, field, actions){
    if(validator && validator.funcs) return validator;
    if(_.isString(validator)) validator = { function: validator };
    //Parse validator function
    var vfuncname = validator.function;
    var vparams = '';
    var vsplit = vfuncname.indexOf(':');
    if (vsplit > 0) { vparams = vfuncname.substr(vsplit + 1); vfuncname = vfuncname.substr(0, vsplit); }
    var vfunccall = '';
    if(vfuncname == 'js'){
      vfunccall = '(function(_caption, _val, _obj){'+validator.function.substr(3)+'})';
    }
    else {
      if (!(('_v_' + vfuncname) in jsh.XValidate)) return validator; //Ignore undefined functions
      var vfunc = jsh.XValidate['_v_' + vfuncname];
      if(('_v_' + vfuncname) in jsh.XValidate.BaseValidators){
        vfunccall = 'XValidate._v_' + vfuncname + '(' + vparams + ')';
      }
      else {
        vfunccall = '('+vfunc.toString()+')(' + vparams + ')';
      }
    }
    //Parse validator actions
    var vactions = ('actions' in validator)?validator.actions:(field.always_editable?XExt.xejs.getActions(model.actions, "BIU"):actions);
    var vcaption = ('caption' in validator)?validator.caption:(field.caption_ext||field.caption);
    var client_validator = {
      actions: vactions,
      caption: vcaption,
      funcs: [vfunccall]
    };
    if('selector' in validator) client_validator.selector = validator.selector;
    return client_validator;
  }

})();